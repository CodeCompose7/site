{{- /* 레이아웃/카드 전용 CSS 번들 */ -}}
{{- $algorithm := .Site.Params.fingerprintAlgorithm | default "sha256" -}}
{{- $layoutsCSS := resources.Get "css/layouts.css" | resources.Minify | resources.Fingerprint $algorithm -}}
<link
  type="text/css"
  rel="stylesheet"
  href="{{ $layoutsCSS.Permalink }}"
  integrity="{{ $layoutsCSS.Data.Integrity }}"
/>

{{/* 마루부리 폰트는 static/fonts 폴더에 직접 파일을 넣어서 사용합니다 */}}
{{/* 폰트 preload: 가장 중요한 폰트를 먼저 로드하여 FOUT 방지 */}}
<link rel="preload" href="/fonts/Pretendard-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="/fonts/MaruBuri-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<script>
(function() {
  function limitTagsToOneLine() {
    const containers = document.querySelectorAll('.article-tags-container');
    
    containers.forEach(container => {
      const wrapper = container.closest('.article-tags-wrapper');
      const skeleton = wrapper ? wrapper.querySelector('.article-tags-skeleton') : null;
      
      // 기존 "..." 태그 제거
      const existingMore = container.querySelector('.article-tag-more');
      if (existingMore) {
        existingMore.remove();
      }
      
      // 모든 태그 표시
      const tags = Array.from(container.querySelectorAll('.article-tag'));
      tags.forEach(tag => tag.classList.remove('hidden'));
      
      // 컨테이너의 너비와 높이 가져오기
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const maxHeightStyle = getComputedStyle(container).maxHeight;
      const maxHeightPx = parseFloat(maxHeightStyle);
      
      // maxHeight가 유효하지 않으면 기본값 사용 (2.25rem = 36px, 16px 기준)
      if (isNaN(maxHeightPx) || maxHeightPx === 0) {
        return; // 스타일이 아직 적용되지 않았을 수 있음
      }
      
      // gap-2 = 0.5rem = 8px
      const gap = 8;
      
      // 태그들의 너비를 순서대로 계산하여 컨테이너 너비를 넘지 않는 태그만 표시
      const visibleTags = [];
      let totalWidth = 0;
      
      // "..." 태그의 예상 너비 (나중에 추가될 수 있음)
      const moreTagWidth = 40; // 대략적인 "..." 태그 너비
      
      for (let i = 0; i < tags.length; i++) {
        const tag = tags[i];
        const tagRect = tag.getBoundingClientRect();
        const tagWidth = tagRect.width;
        
        // 현재 태그 + gap + (마지막 태그가 아니면 다음 태그를 위한 공간, 또는 "..." 태그)
        const neededWidth = totalWidth + tagWidth + (i > 0 ? gap : 0);
        const remainingTags = tags.length - i - 1;
        
        // 마지막 태그가 아니면 "..." 태그 공간도 고려
        const widthWithMore = remainingTags > 0 ? neededWidth + gap + moreTagWidth : neededWidth;
        
        // 컨테이너 너비를 넘지 않으면 추가
        if (widthWithMore <= containerWidth) {
          visibleTags.push(tag);
          totalWidth = neededWidth;
        } else {
          // 넘어가면 중단
          break;
        }
      }
      
      // 보이지 않는 태그 숨기기
      tags.forEach(tag => {
        if (!visibleTags.includes(tag)) {
          tag.classList.add('hidden');
        }
      });
      
      // 숨겨진 태그가 있으면 "..." 태그 추가
      if (visibleTags.length < tags.length) {
        const moreTag = document.createElement('span');
        moreTag.className = 'article-tag-more rounded-md border border-neutral-200 bg-neutral-100 px-2 py-1 text-xs text-neutral-600 dark:border-neutral-600 dark:bg-neutral-700 dark:text-neutral-300 mb-1 mr-1';
        moreTag.textContent = '...';
        moreTag.style.cursor = 'default';
        container.appendChild(moreTag);
      }
      
      // skeleton 숨기고 실제 태그 표시
      if (skeleton) {
        skeleton.classList.add('hidden');
        setTimeout(() => {
          container.classList.add('visible');
        }, 150);
      } else {
        container.classList.add('visible');
      }
    });
  }
  
  // DOM 로드 후 실행 (약간의 지연을 두어 레이아웃이 완전히 렌더링된 후 실행)
  function runLimitTags() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(limitTagsToOneLine, 50);
      });
    } else {
      setTimeout(limitTagsToOneLine, 50);
    }
  }
  
  runLimitTags();
  
  // 리사이즈 이벤트 처리 (반응형 대응)
  let resizeTimer;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(limitTagsToOneLine, 150);
  });
  
  // DOM 로드 후 태그 처리 실행
  function runLimitTags() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(limitTagsToOneLine, 50);
      });
    } else {
      setTimeout(limitTagsToOneLine, 50);
    }
  }
  
  runLimitTags();
  
  // 리사이즈 이벤트 처리 (반응형 대응)
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(limitTagsToOneLine, 150);
  });
})();
</script>

<script>
(function() {
  function measureBaselineHeight(options) {
    const { sampleSelector, wrapperClass } = options;
    const original = document.querySelector(sampleSelector);
    if (!original) return null;

    // 샘플을 감쌀 래퍼 생성 (recent-articles 같은 컨텍스트용)
    const wrapper = document.createElement('div');
    if (wrapperClass) {
      wrapper.className = wrapperClass;
    }
    wrapper.style.position = 'absolute';
    wrapper.style.visibility = 'hidden';
    wrapper.style.pointerEvents = 'none';
    wrapper.style.left = '-9999px';
    wrapper.style.top = '0';

    const sample = original.cloneNode(true);
    // 인라인 스타일 초기화
    sample.style.height = 'auto';
    sample.style.minHeight = '0';
    sample.style.maxHeight = 'none';

    // 제목/요약 영역에 충분한 텍스트를 넣어 line-clamp 기준까지 차도록 함
    const titleEl = sample.querySelector('.article-title-text');
    if (titleEl) {
      titleEl.textContent = 'Sample title text for measuring card height sample title text for measuring.';
    }
    const summaryEl = sample.querySelector('.article-summary');
    if (summaryEl) {
      summaryEl.textContent = 'Sample summary text for measuring card height. '.repeat(20);
    }

    wrapper.appendChild(sample);
    document.body.appendChild(wrapper);

    const rect = sample.getBoundingClientRect();
    const height = rect.height;

    document.body.removeChild(wrapper);
    return height || null;
  }

  function applyEqualMinHeight(selector, minHeight) {
    if (!minHeight) return;
    const cards = document.querySelectorAll(selector);
    if (!cards.length) return;

    cards.forEach(card => {
      card.style.minHeight = ''; // 초기화
      card.style.minHeight = minHeight + 'px';
    });
  }

  function equalizeCards() {
    // 일반 카드(강의 카드 제외, recent-articles 제외)
    const generalSampleSelector = 'article.group:not(.course-card)';
    const generalSample = document.querySelector(generalSampleSelector);
    if (generalSample) {
      const baseHeight = measureBaselineHeight({
        sampleSelector: generalSampleSelector,
      });
      applyEqualMinHeight('article.group:not(.course-card)', baseHeight);
    }

    // 홈 최신 글 카드 (recent-articles 내부)
    const recentSampleSelector = '.recent-articles article.group';
    const recentSample = document.querySelector(recentSampleSelector);
    if (recentSample) {
      const baseRecentHeight = measureBaselineHeight({
        sampleSelector: recentSampleSelector,
        wrapperClass: 'recent-articles',
      });
      applyEqualMinHeight('.recent-articles article.group', baseRecentHeight);
    }
  }

  function runEqualize() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function () {
        // 폰트 렌더링 반영을 위해 약간의 지연
        setTimeout(equalizeCards, 150);
      });
    } else {
      setTimeout(equalizeCards, 150);
    }
  }

  runEqualize();

  let resizeTimer;
  window.addEventListener('resize', function () {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(equalizeCards, 200);
  });
})();
</script>
