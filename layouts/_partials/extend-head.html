{{/* 마루부리 폰트는 static/fonts 폴더에 직접 파일을 넣어서 사용합니다 */}}
{{/* 폰트 preload: 가장 중요한 폰트를 먼저 로드하여 FOUT 방지 */}}
<link rel="preload" href="/fonts/Pretendard-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="/fonts/MaruBuri-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<script>
// 폰트 로딩 확인 후 body 표시
(function() {
  // 최대 대기 시간 (3초)
  const MAX_WAIT_TIME = 3000;
  const startTime = Date.now();
  let fontsLoaded = false;
  
  // body 표시 함수
  function showBody() {
    if (!fontsLoaded) {
      fontsLoaded = true;
      document.body.classList.add('fonts-loaded');
    }
  }
  
  // 폰트 로딩 확인 함수
  function checkFontsLoaded() {
    // document.fonts API 사용 (더 정확한 방법)
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        const elapsed = Date.now() - startTime;
        // 최소 100ms는 기다려서 부드러운 전환
        const delay = Math.max(100, 300 - elapsed);
        setTimeout(showBody, delay);
      }).catch(() => {
        // 폴백: 최대 대기 시간 후 표시
        const elapsed = Date.now() - startTime;
        setTimeout(showBody, Math.max(0, MAX_WAIT_TIME - elapsed));
      });
    } else {
      // document.fonts를 지원하지 않는 브라우저의 경우
      // CSS에서 정의된 폰트가 로드되었는지 확인
      if (document.fonts && document.fonts.check) {
        const checkInterval = setInterval(() => {
          if (document.fonts.check('1em "Pretendard"') && 
              document.fonts.check('1em "MaruBuri"')) {
            clearInterval(checkInterval);
            const elapsed = Date.now() - startTime;
            setTimeout(showBody, Math.max(100, 300 - elapsed));
          }
        }, 50);
        
        // 최대 대기 시간 후 강제로 표시
        setTimeout(() => {
          clearInterval(checkInterval);
          showBody();
        }, MAX_WAIT_TIME);
      } else {
        // 폴백: 짧은 시간 후 표시
        setTimeout(showBody, 500);
      }
    }
  }
  
  // DOM이 준비되면 폰트 확인 시작
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', checkFontsLoaded);
  } else {
    checkFontsLoaded();
  }
  
  // 최대 대기 시간 후 강제로 표시 (폰트 로딩이 너무 오래 걸리는 경우)
  setTimeout(showBody, MAX_WAIT_TIME);
})();
</script>

<script>
(function() {
  function limitTagsToOneLine() {
    const containers = document.querySelectorAll('.article-tags-container');
    
    containers.forEach(container => {
      const wrapper = container.closest('.article-tags-wrapper');
      const skeleton = wrapper ? wrapper.querySelector('.article-tags-skeleton') : null;
      
      // 기존 "..." 태그 제거
      const existingMore = container.querySelector('.article-tag-more');
      if (existingMore) {
        existingMore.remove();
      }
      
      // 모든 태그 표시
      const tags = Array.from(container.querySelectorAll('.article-tag'));
      tags.forEach(tag => tag.classList.remove('hidden'));
      
      // 컨테이너의 너비와 높이 가져오기
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const maxHeightStyle = getComputedStyle(container).maxHeight;
      const maxHeightPx = parseFloat(maxHeightStyle);
      
      // maxHeight가 유효하지 않으면 기본값 사용 (2.25rem = 36px, 16px 기준)
      if (isNaN(maxHeightPx) || maxHeightPx === 0) {
        return; // 스타일이 아직 적용되지 않았을 수 있음
      }
      
      // gap-2 = 0.5rem = 8px
      const gap = 8;
      
      // 태그들의 너비를 순서대로 계산하여 컨테이너 너비를 넘지 않는 태그만 표시
      const visibleTags = [];
      let totalWidth = 0;
      
      // "..." 태그의 예상 너비 (나중에 추가될 수 있음)
      const moreTagWidth = 40; // 대략적인 "..." 태그 너비
      
      for (let i = 0; i < tags.length; i++) {
        const tag = tags[i];
        const tagRect = tag.getBoundingClientRect();
        const tagWidth = tagRect.width;
        
        // 현재 태그 + gap + (마지막 태그가 아니면 다음 태그를 위한 공간, 또는 "..." 태그)
        const neededWidth = totalWidth + tagWidth + (i > 0 ? gap : 0);
        const remainingTags = tags.length - i - 1;
        
        // 마지막 태그가 아니면 "..." 태그 공간도 고려
        const widthWithMore = remainingTags > 0 ? neededWidth + gap + moreTagWidth : neededWidth;
        
        // 컨테이너 너비를 넘지 않으면 추가
        if (widthWithMore <= containerWidth) {
          visibleTags.push(tag);
          totalWidth = neededWidth;
        } else {
          // 넘어가면 중단
          break;
        }
      }
      
      // 보이지 않는 태그 숨기기
      tags.forEach(tag => {
        if (!visibleTags.includes(tag)) {
          tag.classList.add('hidden');
        }
      });
      
      // 숨겨진 태그가 있으면 "..." 태그 추가
      if (visibleTags.length < tags.length) {
        const moreTag = document.createElement('span');
        moreTag.className = 'article-tag-more rounded-md border border-neutral-200 bg-neutral-100 px-2 py-1 text-xs text-neutral-600 dark:border-neutral-600 dark:bg-neutral-700 dark:text-neutral-300 mb-1 mr-1';
        moreTag.textContent = '...';
        moreTag.style.cursor = 'default';
        container.appendChild(moreTag);
      }
      
      // skeleton 숨기고 실제 태그 표시
      if (skeleton) {
        skeleton.classList.add('hidden');
        setTimeout(() => {
          container.classList.add('visible');
        }, 150);
      } else {
        container.classList.add('visible');
      }
    });
  }
  
  // DOM 로드 후 실행 (약간의 지연을 두어 레이아웃이 완전히 렌더링된 후 실행)
  function runLimitTags() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(limitTagsToOneLine, 50);
      });
    } else {
      setTimeout(limitTagsToOneLine, 50);
    }
  }
  
  runLimitTags();
  
  // 리사이즈 이벤트 처리 (반응형 대응)
  let resizeTimer;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(limitTagsToOneLine, 150);
  });
  
  // DOM 로드 후 태그 처리 실행
  function runLimitTags() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(limitTagsToOneLine, 50);
      });
    } else {
      setTimeout(limitTagsToOneLine, 50);
    }
  }
  
  runLimitTags();
  
  // 리사이즈 이벤트 처리 (반응형 대응)
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(limitTagsToOneLine, 150);
  });
})();
</script>
